# =============================================================================
# README (Onju Voice Satellite w/ ESPHome 2025.9.0)
# Hardware pin map (update substitutions below if your PCB revisions differ):
#   • I²S BCLK  -> ${i2s_bclk_pin}
#   • I²S LRCLK -> ${i2s_lrclk_pin}
#   • I²S DOUT  -> ${i2s_dout_pin} (DAC / speaker)
#   • I²S DIN   -> ${i2s_din_pin}  (microphone)
#   • LED ring  -> ${led_data_pin} (${led_pixel_count} px, ${ws2812_variant})
#   • Touch / button -> ${button_touch_pin}
#   • Mic-mute slide (optional) -> ${mute_switch_pin}
#   • Mic-mute LED (optional) -> ${mute_led_pin} (enable via ${mute_led_enabled})
#   • Amplifier enable -> ${amp_enable_pin} | DAC mute -> ${dac_mute_pin}
#
# Remote asset layout (no local FS needed):
#   Attention cues & follow-up tones default to the Home Assistant Voice PE
#   GitHub URLs. Update the *_sound_url substitutions to point at your own
#   HTTPS-hosted WAV/FLAC assets if you prefer custom UX sounds.
#   Wake-word models can be swapped by pointing ${wake_word_model_url} at any
#   microWakeWord JSON/ZIP endpoint (e.g. GitHub release URLs).
#
# Assist pipeline: set ${assist_pipeline} to your Home Assistant Assist pipeline
#   entity_id (e.g. assist_pipeline.default) and ${assist_language} to the
#   pipeline language code used in Home Assistant.
#
# Wake word: defaults to the "okay nabu" microWakeWord release shared by Home
#   Assistant Voice PE. Drop in alternative models by updating the URL &
#   ${wake_word_name}. Keep the optional stop model for barge-in cancelation.
#
# Follow-up listening: Home Assistant automations can call API service
#   `expect_follow_up` with `expected: true` when the Assist response metadata
#   indicates a follow-up is expected. Fallback behaviour is controlled by
#   ${listen_after_questions_default} (set true to force a follow-up window when
#   HA metadata is unavailable).
# =============================================================================
# Feature Parity Checklist (HA Voice PE -> Onju Voice):
#   Wake word + UX → micro_wake_word + script.prepare_session/on_wake_word_detected
#   Barge-in + tap-to-talk → scripts.stop_active_audio/start_session_manual/toggle_mute
#   Attention/busy/error tones → cues_player + play_* scripts (remote GitHub assets)
#   LED state machine → light.ring_light + script.update_leds (idle/listen/process/speak/error/mute/DND)
#   Streaming Assist replies → voice_assistant + pipeline_player (resampler+mixer for partial TTS)
#   Listen after questions → finalize_session/open_follow_up_session + follow_up_guard (+ expect_follow_up API)
#   Follow-up cue → play_follow_up_sound + remote ${follow_up_sound_url}
#   Mic mute & hardware override → software_mute_switch + hardware_mute_switch + apply_mute_state (+ mute LED)
#   DND manual/schedule → evaluate_dnd/update_dnd_state + switches dnd_manual_switch/dnd_schedule_switch
#   OTA/logging/recovery → wifi/api/logger/ota/captive_portal/improv_serial sections
# =============================================================================
# Tuning Tips:
#   • Adjust ${microphone_gain} (micro_wake_word) and voice_assistant auto_gain/noise_suppression for room acoustics.
#   • Modify ${vad_silence_timeout}, ${vad_end_timeout}, ${vad_max_duration} to change VAD sensitivity/timeouts.
#   • Swap attention WAV/FLAC URLs in substitutions to align with your brand.
#   • Edit script.update_leds / light effects to match your LED ring size or branding.
#   • Set ${listen_after_questions_default} to true to always open follow-ups if HA metadata is absent.
# =============================================================================

substitutions:
  device_name: onju-voice-satellite
  friendly_name: Onju Voice Satellite
  project_version: "2.0.0"
  device_description: "Onju Voice ESP32-S3 satellite with ESPHome Assist pipeline"
  assist_pipeline: assist_pipeline.default
  assist_language: en-US
  wifi_fast_connect: "false"
  timezone: "Etc/UTC"
  audio_sample_rate: "48000"
  microphone_gain: "4"
  led_enabled: "true"
  led_pixel_count: "6"
  led_last_index: "5"
  led_data_pin: GPIO11
  ws2812_variant: SK6812
  led_idle_brightness: "35%"
  led_listening_brightness: "100%"
  led_processing_brightness: "90%"
  led_speaking_brightness: "85%"
  wake_word_model_url: "https://github.com/kahrendt/microWakeWord/releases/download/okay_nabu_20241226.3/okay_nabu.json"
  wake_word_name: "okay nabu"
  wake_word_start_delay: "120ms"
  follow_up_timeout: "7s"
  follow_up_sound_url: "https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_double_press.flac"
  start_listening_sound_url: "https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/wake_word_triggered.flac"
  end_listening_sound_url: "https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_off.flac"
  thinking_sound_url: "https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_press.flac"
  success_sound_url: "https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/jack_connected.flac"
  error_sound_url: "https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/jack_disconnected.flac"
  busy_sound_url: "https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_triple_press.flac"
  attention_volume: "65%"
  pipeline_volume: "85%"
  vad_silence_timeout: "1200ms"
  vad_end_timeout: "600ms"
  vad_max_duration: "15000ms"
  listen_after_questions_default: "false"
  button_touch_pin: GPIO3
  button_touch_threshold: "750000"
  button_short_press_max: "600ms"
  button_long_press_min: "900ms"
  mute_switch_pin: GPIO38
  mute_led_enabled: "false"
  mute_led_pin: GPIO7
  amp_enable_pin: GPIO1
  dac_mute_pin: GPIO21
  i2s_lrclk_pin: GPIO13
  i2s_bclk_pin: GPIO18
  i2s_dout_pin: GPIO12
  i2s_din_pin: GPIO17
  wifi_reboot_timeout: "15min"
  dnd_schedule_enabled: "true"
  dnd_start_hour: "23"
  dnd_start_minute: "00"
  dnd_end_hour: "06"
  dnd_end_minute: "30"
  state_idle: "0"
  state_listening: "2"
  state_processing: "3"
  state_speaking: "4"
  state_error: "5"
  state_muted: "6"

esphome:
  name: "${device_name}"
  friendly_name: "${friendly_name}"
  comment: "${device_description}"
  name_add_mac_suffix: true
  project:
    name: onju.voice_satellite
    version: "${project_version}"
  min_version: 2025.9.0
  on_boot:
    priority: 600
    then:
      - switch.turn_on: speaker_soft_mute
      - switch.turn_off: speaker_amp
      - if:
          condition:
            lambda: return id(software_muted);
          then:
            - switch.turn_on: software_mute_switch
      - lambda: |-
          id(assistant_state) = ${state_idle};
          id(conversation_active) = false;
      - script.execute: update_leds
      - delay: 1s
      - script.execute: apply_mute_state
      - script.execute: evaluate_dnd
      - script.execute: rearm_hotword

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"
      CONFIG_SPIRAM_RODATA: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: "y"

psram:
  mode: octal
  speed: 80MHz

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: ${wifi_fast_connect}
  reboot_timeout: ${wifi_reboot_timeout}
  ap:
    ssid: "${friendly_name} Fallback"
    password: "OnjuVoiceSetup"
  on_connect:
    - script.execute: evaluate_dnd
    - script.execute: rearm_hotword
  on_disconnect:
    - micro_wake_word.stop
    - script.execute: update_leds

captive_portal:

improv_serial:

logger:
  level: INFO
  baud_rate: 115200

api:
  encryption:
    key: !secret api_encryption_key
  reboot_timeout: 0s
  services:
    - service: expect_follow_up
      variables:
        expected: bool
      then:
        - lambda: id(follow_up_hint) = expected;
    - service: play_feedback
      variables:
        sound: string
      then:
        - script.execute:
            id: play_sound_router
            sound: !lambda return sound;

ota:
  - platform: esphome
    password: !secret ota_password

safe_mode:

network:
  enable_ipv6: true

time:
  - platform: sntp
    id: sntp_time
    timezone: ${timezone}
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
    on_time:
      - seconds: 0
        minutes: /5
        then:
          - script.execute: evaluate_dnd

i2s_audio:
  - id: i2s_out
    i2s_lrclk_pin:
      number: ${i2s_lrclk_pin}
      allow_other_uses: true
    i2s_bclk_pin:
      number: ${i2s_bclk_pin}
      allow_other_uses: true
  - id: i2s_in
    i2s_lrclk_pin:
      number: ${i2s_lrclk_pin}
      allow_other_uses: true
    i2s_bclk_pin:
      number: ${i2s_bclk_pin}
      allow_other_uses: true

speaker:
  - platform: i2s_audio
    id: speaker_hw
    i2s_audio_id: i2s_out
    i2s_dout_pin: ${i2s_dout_pin}
    sample_rate: ${audio_sample_rate}
    bits_per_sample: 16bit
    channel: stereo
    dac_type: external
    i2s_mode: primary
    timeout: 500ms
    buffer_duration: 200ms
  - platform: mixer
    id: speaker_mixer
    output_speaker: speaker_hw
    source_speakers:
      - id: cues_stream_input
        timeout: 1500ms
      - id: pipeline_announcement_input
        timeout: 4000ms
      - id: pipeline_media_input
        timeout: 4000ms
  - platform: resampler
    id: cues_stream
    output_speaker: cues_stream_input
    sample_rate: ${audio_sample_rate}
  - platform: resampler
    id: pipeline_announcement_stream
    output_speaker: pipeline_announcement_input
    sample_rate: ${audio_sample_rate}
  - platform: resampler
    id: pipeline_media_stream
    output_speaker: pipeline_media_input
    sample_rate: ${audio_sample_rate}

microphone:
  - platform: i2s_audio
    id: onju_mic
    i2s_audio_id: i2s_in
    i2s_din_pin: ${i2s_din_pin}
    use_apll: true
    channel: stereo
    sample_rate: 16000
    bits_per_sample: 32bit
    pdm: false
    adc_type: external

media_player:
  - platform: speaker
    id: cues_player
    internal: true
    name: "${friendly_name} cues"
    announcement_pipeline:
      speaker: cues_stream
      num_channels: 2
      format: FLAC
      sample_rate: ${audio_sample_rate}
    volume_initial: ${attention_volume}
    on_play:
      - script.execute: ensure_amp_on
    on_announcement:
      - script.execute: ensure_amp_on
    on_idle:
      - script.execute: maybe_power_down_amp
    files:
      - id: start_listen
        file: ${start_listening_sound_url}
      - id: end_listen
        file: ${end_listening_sound_url}
      - id: thinking
        file: ${thinking_sound_url}
      - id: success
        file: ${success_sound_url}
      - id: error
        file: ${error_sound_url}
      - id: busy
        file: ${busy_sound_url}
      - id: follow_up
        file: ${follow_up_sound_url}
  - platform: speaker
    id: pipeline_player
    internal: true
    name: "${friendly_name} assist"
    announcement_pipeline:
      speaker: pipeline_announcement_stream
      num_channels: 2
      format: WAV
      sample_rate: ${audio_sample_rate}
    media_pipeline:
      speaker: pipeline_media_stream
      num_channels: 2
      format: WAV
      sample_rate: ${audio_sample_rate}
    volume_initial: ${pipeline_volume}
    on_play:
      - script.execute: ensure_amp_on
    on_pause:
      - script.execute: maybe_power_down_amp
    on_idle:
      - script.execute: maybe_power_down_amp

micro_wake_word:
  id: mww
  microphone:
    microphone: onju_mic
    channels: 1
    gain_factor: ${microphone_gain}
  stop_after_detection: false
  models:
    - id: primary
      model: ${wake_word_model_url}
    - id: stop
      model: https://github.com/kahrendt/microWakeWord/releases/download/stop/stop.json
      internal: true
  on_wake_word_detected:
    - if:
        condition:
          lambda: return id(mic_muted) || id(dnd_active);
        then:
          - script.execute: play_busy_sound
        else:
          - script.execute:
              id: prepare_session
              sound: "start"
          - voice_assistant.start:
              id: va
              wake_word: !lambda return wake_word;

voice_assistant:
  id: va
  microphone:
    microphone: onju_mic
    channels: 1
  media_player: pipeline_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 2
  auto_gain: 0 dbfs
  volume_multiplier: 1.0
  on_start:
    - lambda: id(conversation_active) = true;
    - micro_wake_word.stop
  on_listening:
    - lambda: id(assistant_state) = ${state_listening};
    - script.execute: update_leds
  on_stt_vad_start:
    - lambda: id(assistant_state) = ${state_listening};
    - script.execute: update_leds
  on_stt_vad_end:
    - lambda: id(assistant_state) = ${state_processing};
    - script.execute: update_leds
    - script.execute: play_end_sound
    - script.execute: play_thinking_sound
  on_intent_progress:
    - if:
        condition:
          lambda: 'return !x.empty();'
        then:
          - lambda: id(assistant_state) = ${state_speaking};
          - script.execute: update_leds
          - script.execute: ensure_amp_on
  on_tts_start:
    - lambda: id(assistant_state) = ${state_speaking};
    - lambda: id(conversation_had_tts) = true;
    - script.execute: update_leds
    - script.execute: ensure_amp_on
  on_error:
    - lambda: |-
        id(error_active) = true;
        id(last_error_code) = code;
        id(assistant_state) = ${state_error};
    - script.execute: update_leds
    - script.execute: play_error_sound
  on_end:
    - script.execute: finalize_session
  on_client_connected:
    - script.execute: rearm_hotword
  on_client_disconnected:
    - voice_assistant.stop:
        id: va
    - script.execute: stop_active_audio

light:
  - platform: esp32_rmt_led_strip
    id: ring_pixels
    internal: true
    pin: ${led_data_pin}
    chipset: ${ws2812_variant}
    num_leds: ${led_pixel_count}
    rgb_order: grb
    default_transition_length: 0s
    effects:
      - pulse:
          name: idle_breathe
          transition_length: 2s
          update_interval: 2s
      - strobe:
          name: wake_flash
          colors:
            - state: ON
              brightness: 100%
              red: 100%
              green: 60%
              blue: 0%
              duration: 120ms
            - state: OFF
              duration: 80ms
      - addressable_scan:
          name: listening_spinner
          move_interval: 60ms
          scan_width: 4
      - addressable_scan:
          name: processing_pulse
          move_interval: 90ms
          scan_width: 5
      - addressable_twinkle:
          name: speaking_wipe
          twinkle_probability: 35%
      - strobe:
          name: error_flash
          colors:
            - state: ON
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 180ms
            - state: ON
              brightness: 10%
              red: 15%
              green: 0%
              blue: 0%
              duration: 180ms
  - platform: partition
    id: ring_light
    segments:
      - id: ring_pixels
        from: 0
        to: ${led_last_index}
    default_transition_length: 0s

output:
  - platform: gpio
    id: mute_led
    pin:
      number: ${mute_led_pin}
      inverted: false

switch:
  - platform: template
    id: software_mute_switch
    name: "${friendly_name} Microphone Mute"
    icon: mdi:microphone-off
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - lambda: id(software_muted) = true;
      - script.execute: apply_mute_state
    on_turn_off:
      - lambda: id(software_muted) = false;
      - script.execute: apply_mute_state
  - platform: template
    id: wake_word_switch
    name: "${friendly_name} Wake Word"
    icon: mdi:account-voice
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_on:
      - script.execute: rearm_hotword
    on_turn_off:
      - script.execute: rearm_hotword
  - platform: template
    id: attention_sounds_switch
    name: "${friendly_name} Attention Sounds"
    icon: mdi:volume-high
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: follow_up_switch
    name: "${friendly_name} Listen After Response"
    icon: mdi:account-tie-voice
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: dnd_manual_switch
    name: "${friendly_name} Do Not Disturb"
    icon: mdi:moon-waning-crescent
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - lambda: id(manual_dnd) = true;
      - script.execute: update_dnd_state
    on_turn_off:
      - lambda: id(manual_dnd) = false;
      - script.execute: update_dnd_state
  - platform: template
    id: dnd_schedule_switch
    name: "${friendly_name} DND Schedule"
    icon: mdi:calendar-clock
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_on:
      - script.execute: evaluate_dnd
    on_turn_off:
      - script.execute: evaluate_dnd
  - platform: template
    id: led_enable_switch
    name: "${friendly_name} LEDs"
    icon: mdi:led-strip-variant
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_on:
      - lambda: id(led_enabled_runtime) = true;
      - script.execute: update_leds
    on_turn_off:
      - lambda: id(led_enabled_runtime) = false;
      - light.turn_off: ring_light
  - platform: gpio
    id: speaker_amp
    internal: true
    restore_mode: RESTORE_DEFAULT_OFF
    pin: ${amp_enable_pin}
  - platform: gpio
    id: speaker_soft_mute
    internal: true
    restore_mode: ALWAYS_ON
    pin:
      number: ${dac_mute_pin}
      inverted: true

select:
  - platform: template
    id: idle_led_animation_select
    name: "${friendly_name} Idle Animation"
    icon: mdi:led-strip-variant
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: 'idle_breathe'
    options: &led_effect_options
      - 'idle_breathe'
      - 'wake_flash'
      - 'listening_spinner'
      - 'processing_pulse'
      - 'speaking_wipe'
      - 'error_flash'
      - 'None'
    set_action:
      - script.execute: update_leds
  - platform: template
    id: dnd_led_animation_select
    name: "${friendly_name} DND Animation"
    icon: mdi:led-strip-variant
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: 'idle_breathe'
    options: *led_effect_options
    set_action:
      - script.execute: update_leds
  - platform: template
    id: listening_led_animation_select
    name: "${friendly_name} Listening Animation"
    icon: mdi:led-strip-variant
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: 'listening_spinner'
    options: *led_effect_options
    set_action:
      - script.execute: update_leds
  - platform: template
    id: processing_led_animation_select
    name: "${friendly_name} Processing Animation"
    icon: mdi:led-strip-variant
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: 'processing_pulse'
    options: *led_effect_options
    set_action:
      - script.execute: update_leds
  - platform: template
    id: speaking_led_animation_select
    name: "${friendly_name} Speaking Animation"
    icon: mdi:led-strip-variant
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: 'speaking_wipe'
    options: *led_effect_options
    set_action:
      - script.execute: update_leds
  - platform: template
    id: error_led_animation_select
    name: "${friendly_name} Error Animation"
    icon: mdi:led-strip-variant
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: 'error_flash'
    options: *led_effect_options
    set_action:
      - script.execute: update_leds
  - platform: template
    id: muted_led_animation_select
    name: "${friendly_name} Muted Animation"
    icon: mdi:led-strip-variant
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: 'None'
    options: *led_effect_options
    set_action:
      - script.execute: update_leds
  - platform: template
    id: wake_led_animation_select
    name: "${friendly_name} Wake Animation"
    icon: mdi:led-strip-variant
    entity_category: config
    optimistic: true
    restore_value: true
    initial_option: 'wake_flash'
    options: *led_effect_options
    set_action:
      - script.execute: update_leds

esp32_touch:
  sleep_duration: 1ms
  measurement_duration: 800us

binary_sensor:
  - platform: esp32_touch
    id: assistant_button
    name: "${friendly_name} Touch Button"
    icon: mdi:gesture-tap-button
    pin: ${button_touch_pin}
    threshold: ${button_touch_threshold}
    filters:
      - delayed_on: 30ms
      - delayed_off: 30ms
    on_click:
      - min_length: 50ms
        max_length: ${button_short_press_max}
        then:
          - script.execute:
              id: start_session_manual
              reason: "tap"
              sound: "start"
      - min_length: ${button_long_press_min}
        max_length: 5s
        then:
          - script.execute: toggle_mute
  - platform: gpio
    id: hardware_mute_switch
    internal: true
    pin:
      number: ${mute_switch_pin}
      mode: INPUT_PULLUP
    filters:
      - delayed_on: 20ms
      - delayed_off: 20ms
    on_state:
      - script.execute: apply_mute_state
  - platform: template
    id: dnd_state_sensor
    name: "${friendly_name} DND Active"
    device_class: safety
    entity_category: diagnostic
    lambda: 'return id(dnd_active);'
  - platform: template
    id: follow_up_active_sensor
    name: "${friendly_name} Follow-up Window"
    entity_category: diagnostic
    lambda: 'return id(follow_up_open);'

sensor:
  - platform: wifi_signal
    name: "${friendly_name} Wi-Fi RSSI"
    update_interval: 60s
  - platform: uptime
    name: "${friendly_name} Uptime"
    update_interval: 60s

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP"
  - platform: template
    name: "${friendly_name} Assist Phase"
    update_interval: 2s
    lambda: |-
      switch (id(assistant_state)) {
        case ${state_idle}:
          return id(follow_up_open) ? "follow-up-ready" : "idle";
        case ${state_listening}:
          return "listening";
        case ${state_processing}:
          return "processing";
        case ${state_speaking}:
          return "speaking";
        case ${state_error}:
          return "error";
        case ${state_muted}:
          return "muted";
        default:
          return "idle";
      }
  - platform: template
    name: "${friendly_name} Last Error"
    entity_category: diagnostic
    update_interval: 5s
    lambda: |-
      return id(last_error_code);

button:
  - platform: restart
    name: "${friendly_name} Restart"
    entity_category: diagnostic
  - platform: safe_mode
    name: "${friendly_name} Safe Mode"
    entity_category: diagnostic

globals:
  - id: assistant_state
    type: uint8_t
    restore_value: no
    initial_value: ${state_idle}
  - id: software_muted
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: mic_muted
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: error_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: conversation_had_tts
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: conversation_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: follow_up_hint
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: follow_up_open
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: pending_follow_up
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: led_enabled_runtime
    type: bool
    restore_value: yes
    initial_value: ${led_enabled}
  - id: last_error_code
    type: std::string
    restore_value: no
    initial_value: "\"\""
  - id: manual_dnd
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: schedule_dnd
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: dnd_active
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: dnd_state_changed
    type: bool
    restore_value: no
    initial_value: 'false'

script:
  - id: update_leds
    mode: queued
    then:
      - lambda: |-
          if (!id(led_enabled_runtime)) {
            id(ring_light).turn_off();
            return;
          }

          auto parse_pct = [](const char *value) -> float {
            std::string str(value);
            auto pos = str.find('%');
            if (pos != std::string::npos) {
              str = str.substr(0, pos);
            }
            return atof(str.c_str()) / 100.0f;
          };

          float brightness = parse_pct("${led_idle_brightness}");
          float red = 0.0f;
          float green = 0.3f;
          float blue = 0.8f;
          std::string effect = id(idle_led_animation_select).state;

          if (id(mic_muted)) {
            brightness = 0.35f;
            red = 1.0f;
            green = 0.10f;
            blue = 0.10f;
            effect = id(muted_led_animation_select).state;
          } else if (id(assistant_state) == ${state_error}) {
            brightness = 1.0f;
            red = 1.0f;
            green = 0.0f;
            blue = 0.0f;
            effect = id(error_led_animation_select).state;
          } else if (id(dnd_active)) {
            brightness = 0.20f;
            red = 0.50f;
            green = 0.0f;
            blue = 0.80f;
            effect = id(dnd_led_animation_select).state;
          } else if (id(assistant_state) == ${state_listening}) {
            brightness = parse_pct("${led_listening_brightness}");
            red = 0.05f;
            green = 0.90f;
            blue = 0.80f;
            effect = id(listening_led_animation_select).state;
          } else if (id(assistant_state) == ${state_processing}) {
            brightness = parse_pct("${led_processing_brightness}");
            red = 1.0f;
            green = 0.50f;
            blue = 0.0f;
            effect = id(processing_led_animation_select).state;
          } else if (id(assistant_state) == ${state_speaking}) {
            brightness = parse_pct("${led_speaking_brightness}");
            red = 0.80f;
            green = 0.60f;
            blue = 0.20f;
            effect = id(speaking_led_animation_select).state;
          }

          auto call = id(ring_light).turn_on();
          call.set_brightness(brightness);
          call.set_red(red);
          call.set_green(green);
          call.set_blue(blue);
          call.set_effect(effect.c_str());
          call.perform();
  - id: prepare_session
    mode: restart
    parameters:
      sound: string
    then:
      - script.stop: follow_up_guard
      - script.execute: stop_active_audio
      - lambda: |-
          id(conversation_active) = true;
          id(error_active) = false;
          id(conversation_had_tts) = false;
          id(pending_follow_up) = false;
          id(follow_up_hint) = false;
      - micro_wake_word.stop
      - script.execute: ensure_amp_on
      - lambda: |-
          id(follow_up_open) = (sound == "follow");
      - if:
          condition:
            lambda: return id(led_enabled_runtime);
          then:
            - light.turn_on:
                id: ring_light
                effect: !lambda return id(wake_led_animation_select).state;
                brightness: ${led_listening_brightness}
                red: 100%
                green: 60%
                blue: 0%
      - if:
          condition:
            lambda: return sound == "follow";
          then:
            - script.execute: play_follow_up_sound
          else:
            - if:
                condition:
                  lambda: return sound == "start";
                then:
                  - script.execute: play_start_sound
      - delay: ${wake_word_start_delay}
      - lambda: id(assistant_state) = ${state_listening};
      - script.execute: update_leds
  - id: start_session_manual
    mode: restart
    parameters:
      reason: string
      sound: string
    then:
      - if:
          condition:
            lambda: return id(mic_muted) || id(dnd_active);
          then:
            - script.execute: play_busy_sound
          else:
            - script.execute:
                id: prepare_session
                sound: !lambda return sound;
            - voice_assistant.start:
                id: va
  - id: open_follow_up_session
    mode: restart
    then:
      - if:
          condition:
            lambda: return id(mic_muted) || id(dnd_active);
          then:
            - lambda: id(pending_follow_up) = false;
            - script.execute: rearm_hotword
          else:
            - lambda: id(pending_follow_up) = false;
            - script.execute:
                id: prepare_session
                sound: "follow"
            - voice_assistant.start:
                id: va
            - script.execute: follow_up_guard
  - id: follow_up_guard
    mode: restart
    then:
      - delay: ${follow_up_timeout}
      - if:
          condition:
            not:
              voice_assistant.is_running:
                id: va
          then:
            - lambda: |-
                id(follow_up_open) = false;
                if (!id(conversation_active)) {
                  id(assistant_state) = id(mic_muted) ? ${state_muted} : ${state_idle};
                }
            - script.execute: update_leds
            - script.execute: rearm_hotword
            - script.execute: maybe_power_down_amp
  - id: play_start_sound
    mode: restart
    then:
      - if:
          condition:
            switch.is_on: attention_sounds_switch
          then:
            - script.execute: ensure_amp_on
            - media_player.speaker.play_on_device_media_file:
                id: cues_player
                media_file: start_listen
                announcement: true
  - id: play_follow_up_sound
    mode: restart
    then:
      - if:
          condition:
            switch.is_on: attention_sounds_switch
          then:
            - script.execute: ensure_amp_on
            - media_player.speaker.play_on_device_media_file:
                id: cues_player
                media_file: follow_up
                announcement: true
  - id: play_end_sound
    mode: restart
    then:
      - if:
          condition:
            switch.is_on: attention_sounds_switch
          then:
            - script.execute: ensure_amp_on
            - media_player.speaker.play_on_device_media_file:
                id: cues_player
                media_file: end_listen
                announcement: true
  - id: play_thinking_sound
    mode: restart
    then:
      - if:
          condition:
            switch.is_on: attention_sounds_switch
          then:
            - delay: 120ms
            - script.execute: ensure_amp_on
            - media_player.speaker.play_on_device_media_file:
                id: cues_player
                media_file: thinking
                announcement: true
  - id: play_success_sound
    mode: restart
    then:
      - if:
          condition:
            switch.is_on: attention_sounds_switch
          then:
            - script.execute: ensure_amp_on
            - media_player.speaker.play_on_device_media_file:
                id: cues_player
                media_file: success
                announcement: true
  - id: play_error_sound
    mode: restart
    then:
      - script.execute: ensure_amp_on
      - media_player.speaker.play_on_device_media_file:
          id: cues_player
          media_file: error
          announcement: true
  - id: play_busy_sound
    mode: restart
    then:
      - if:
          condition:
            switch.is_on: attention_sounds_switch
          then:
            - script.execute: ensure_amp_on
            - media_player.speaker.play_on_device_media_file:
                id: cues_player
                media_file: busy
                announcement: true
  - id: play_sound_router
    mode: restart
    parameters:
      sound: string
    then:
      - if:
          condition:
            lambda: return sound == "start";
          then:
            - script.execute: play_start_sound
          else:
            - if:
                condition:
                  lambda: return sound == "follow";
                then:
                  - script.execute: play_follow_up_sound
                else:
                  - if:
                      condition:
                        lambda: return sound == "end";
                      then:
                        - script.execute: play_end_sound
                      else:
                        - if:
                            condition:
                              lambda: return sound == "thinking";
                            then:
                              - script.execute: play_thinking_sound
                            else:
                              - if:
                                  condition:
                                    lambda: return sound == "success";
                                  then:
                                    - script.execute: play_success_sound
                                  else:
                                    - if:
                                        condition:
                                          lambda: return sound == "error";
                                        then:
                                          - script.execute: play_error_sound
                                        else:
                                          - if:
                                              condition:
                                                lambda: return sound == "busy";
                                              then:
                                                - script.execute: play_busy_sound
                                              else:
                                                - lambda: ESP_LOGW("feedback", "Unknown feedback sound '%s'", sound.c_str());
  - id: stop_active_audio
    mode: restart
    then:
      - script.stop: follow_up_guard
      - speaker.stop: speaker_hw
      - if:
          condition:
            voice_assistant.is_running:
              id: va
          then:
            - voice_assistant.stop:
                id: va
            - wait_until:
                timeout: 750ms
                condition:
                  lambda: return !id(va).is_running();
      - lambda: |-
          id(conversation_active) = false;
          id(conversation_had_tts) = false;
          id(follow_up_open) = false;
          id(pending_follow_up) = false;
      - switch.turn_on: speaker_soft_mute
  - id: ensure_amp_on
    mode: queued
    then:
      - if:
          condition:
            switch.is_off: speaker_amp
          then:
            - switch.turn_on: speaker_amp
            - delay: 30ms
      - if:
          condition:
            switch.is_on: speaker_soft_mute
          then:
            - switch.turn_off: speaker_soft_mute
  - id: maybe_power_down_amp
    mode: restart
    then:
      - if:
          condition:
            and:
              - not:
                  voice_assistant.is_running:
                    id: va
              - not:
                  media_player.is_playing:
                    id: pipeline_player
              - not:
                  media_player.is_playing:
                    id: cues_player
              - not:
                  media_player.is_announcing:
                    id: cues_player
          then:
          - if:
              condition:
                switch.is_off: speaker_soft_mute
              then:
              - switch.turn_on: speaker_soft_mute
          - delay: 50ms
          - if:
              condition:
                switch.is_on: speaker_amp
              then:
              - switch.turn_off: speaker_amp
  - id: apply_mute_state
    mode: queued
    then:
      - lambda: |-
          bool hardware = id(hardware_mute_switch).state;
          bool software = id(software_muted);
          bool final_muted = hardware || software;
          id(mic_muted) = final_muted;
          if (final_muted) {
            id(follow_up_hint) = false;
            id(pending_follow_up) = false;
          }
      - if:
          condition:
            lambda: return id(mic_muted);
          then:
            - script.execute: stop_active_audio
            - microphone.mute: onju_mic
            - lambda: id(assistant_state) = ${state_muted};
            - script.execute: update_leds
            - script.execute: rearm_hotword
          else:
            - microphone.unmute: onju_mic
            - if:
                condition:
                  lambda: return !id(conversation_active);
                then:
                  - lambda: id(assistant_state) = ${state_idle};
                  - script.execute: update_leds
      - script.execute: rearm_hotword
      - script.execute: update_mute_led
  - id: update_mute_led
    then:
      - if:
          condition:
            lambda: return ${mute_led_enabled};
          then:
            - if:
                condition:
                  lambda: return id(mic_muted);
                then:
                  - output.turn_on: mute_led
                else:
                  - output.turn_off: mute_led
  - id: rearm_hotword
    mode: queued
    then:
      - lambda: |-
          bool should_listen = !id(mic_muted) && !id(dnd_active) && !id(conversation_active) && id(wake_word_switch).state;
          if (should_listen) {
            if (!id(mww).is_running()) {
              id(mww).start();
            }
          } else {
            if (id(mww).is_running()) {
              id(mww).stop();
            }
          }
  - id: finalize_session
    mode: restart
    then:
      - script.stop: follow_up_guard
      - lambda: |-
          id(conversation_active) = false;
          const bool fallback_follow = ${listen_after_questions_default};
          bool should_follow = (id(follow_up_hint) || fallback_follow) && id(follow_up_switch).state && id(conversation_had_tts) && !id(mic_muted) && !id(dnd_active);
          id(pending_follow_up) = should_follow;
          id(follow_up_hint) = false;
      - if:
          condition:
            lambda: return id(error_active);
          then:
            - lambda: |-
                id(error_active) = false;
                id(conversation_had_tts) = false;
                id(follow_up_open) = false;
                id(pending_follow_up) = false;
                id(assistant_state) = id(mic_muted) ? ${state_muted} : ${state_idle};
            - script.execute: update_leds
            - script.execute: rearm_hotword
            - script.execute: maybe_power_down_amp
          else:
            - if:
                condition:
                  lambda: return id(pending_follow_up);
                then:
                  - script.execute: open_follow_up_session
                else:
                  - if:
                      condition:
                        lambda: return id(conversation_had_tts) && !id(mic_muted) && !id(dnd_active);
                      then:
                        - script.execute: play_success_sound
                  - lambda: |-
                      id(conversation_had_tts) = false;
                      id(follow_up_open) = false;
                      id(pending_follow_up) = false;
                      id(assistant_state) = id(mic_muted) ? ${state_muted} : ${state_idle};
                  - script.execute: update_leds
                  - script.execute: rearm_hotword
                  - script.execute: maybe_power_down_amp
      - lambda: |-
          id(conversation_had_tts) = false;
          id(follow_up_open) = false;
          id(pending_follow_up) = false;
  - id: evaluate_dnd
    mode: restart
    then:
      - if:
          condition:
            lambda: return ${dnd_schedule_enabled} && id(dnd_schedule_switch).state && id(sntp_time).now().is_valid();
          then:
            - lambda: |-
                auto now = id(sntp_time).now();
                if (!now.is_valid()) {
                  return;
                }
                int start_minutes = ${dnd_start_hour} * 60 + ${dnd_start_minute};
                int end_minutes = ${dnd_end_hour} * 60 + ${dnd_end_minute};
                int current = now.hour * 60 + now.minute;
                bool active = false;
                if (start_minutes <= end_minutes) {
                  active = current >= start_minutes && current < end_minutes;
                } else {
                  active = (current >= start_minutes) || (current < end_minutes);
                }
                id(schedule_dnd) = active;
          else:
            - lambda: id(schedule_dnd) = false;
      - script.execute: update_dnd_state
  - id: update_dnd_state
    mode: restart
    then:
      - lambda: |-
          bool new_state = id(manual_dnd) || id(schedule_dnd);
          id(dnd_state_changed) = (new_state != id(dnd_active));
          id(dnd_active) = new_state;
      - if:
          condition:
            lambda: return id(dnd_state_changed);
          then:
            - if:
                condition:
                  lambda: return id(dnd_active);
                then:
                  - script.execute: stop_active_audio
                  - script.execute: rearm_hotword
      - script.execute: update_leds
      - lambda: id(dnd_state_changed) = false
  - id: toggle_mute
    then:
      - if:
          condition:
            lambda: return id(software_muted);
          then:
            - switch.turn_off: software_mute_switch
          else:
            - switch.turn_on: software_mute_switch
